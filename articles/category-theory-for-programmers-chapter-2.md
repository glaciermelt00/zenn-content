---
title: "Category Theory For Programmers Chapter 2"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Scala]
published: false
---

# Chapter 2 Types and Functions  型と関数

型と関数という圏は、プログラミングにおいて重要な役割を果たします。
ここでは、型とは何か、なぜ肩が必要なのかを説明します。

## 2.1 Who Needs Types?  型が必要な人とは？

静的型付けと動的型付け、強い型付けと弱い型付けの利点については、いくつかの論争があるようです。
これらの選択について、思考実験で説明してみましょう。
何百匹ものサルがコンピュータのキーボードで楽しそうにランダムなキーを打ち、プログラムを作り、コンパイルし、実行しているとします。
機械語であれば、猿が作ったどんなバイトの組み合わせでも受け入れて実行することができます。
しかし、上位の言語では、コンパイラが字句や文法の誤りを検出してくれるのはありがたいことです。
多くの猿がバナナを食べずに死んでしまうが、残ったプログラムは役に立つ可能性が高くなります。
型チェックは、無意味なプログラムに対するもう１つの障壁となります。
さらに、動的型付けされた言語では、型の不一致は実行時に発見されますが、強型付けされた静的検査の言語では型の不一致はコンパイル時に発見されるので、多くの間違ったプログラムが実行される前に排除されます。

問題は、猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか、ということです。

タイピングモンキーの思考実験における通常の目標は、シェークスピアの全集を作ることです。
スペルチェッカーと文法チェッカーがループに入っていれば、その確率は飛躍的に高まります。
タイプチェッカーのアナログは更に進んで、ロミオが人間と宣言されたら、葉っぱを生やしたり、強力な重力で講師を閉じ込めたりしないようにする。

## 2.2 Types Are About Composability  型とは合成可能性のこと

圏論とは、矢印を合成することです。
しかし、どんな２つの矢印でも合成することはできません。
ある矢印のターゲットオブジェクトは、次の矢印のソースオブジェクトと同じでなければなりません。
プログラミングでは、ある関数の結果を別の関数に渡します。
ターゲット関数がソース関数の生成したデータを正しく解釈できなければ、プログラムは動作しません。
合成が機能するためには、2 つの端が合わなければなりません。その言語の型システムが強力であればあるほど、この一致を記述し、機械的に検証することができます。

強力な静的型検査に反対する唯一の重大な論点は、意味的に正しいプログラムを排除してしまう可能性があるということです。
実際には、このようなことは極めて稀であり、いずれにしても、どの言語も、本当に必要な場合には、型システムをバイパスするためのなんらかの裏口を用意しています。
しかし、そのような装置は慎重に使うべきです。

型を扱うことはプログラマに大きな負担を強いることになる、というのもよく耳にする議論です。
私自身、 C++ でイテレータの宣言を何度か書いたことがあるので、この意見には共感できましたが、型推論と呼ばれる技術があり、コンパイラが使用されている文脈からほとんどの型を推定することができるようになりました。
C++ では、変数 auto を宣言すると、コンパイラがその型を判断してくれるようになりました。

Haskell では、稀な場合を除いて、型の注釈は純粋にオプションです。
プログラマーは型注釈を使う傾向にあります。
なぜなら、型注釈はコードのセマンティクスについて多くのことを教えてくれるし、、コンパイルエラーを分かりやすくしてくれるからです。
Haskell では、型の設計からプロジェクトを始めるのが一般的です。
その後、型注釈が実装を推進し、コンパイラによって強制されたコメントになります。

強力な静的型付けは、コードをテストしない言い訳としてよく使われます。
Haskell のプログラマが「コンパイルできなら、正しいに違いありません」と言っているのを耳にすることがあります。
もちろん、型付けが正しいプログラムが、正しい出力をするという意味で正しいという保証はありません。
このような軽率な態度の結果、いくつかの研究では、 Haskell はコード品質において、期待されたほど強く優位に立つことができませんでした。
どうやら商業的な環境では、バグを修正するという圧力は、ある品質レベルまでしか適用されず、それはソフトウェア開発の経済性やエンドユーザーの許容範囲と関係があり、プログラミング言語や方法論とはほとんど関係がありません。
もっと良い基準は、どれだけのプロジェクトがスケジュールに遅れたり、機能が大幅に縮小されて納品されたかを測ることです。

ユニットテストが強力な型付けにとって変わることができるという議論については、よく行われるリファクタリングを考えてみましょう: 特定の関数の引数の型を変更すること。
強く型付けされた言語ではその関数の宣言を変更して、全てのビルドブレークを修正するだけで十分です。
弱く型付けされた言語では関数が異なるデータを要求するようになったという事実は、呼び出しサイトには伝わりません。
ユニットテストではミスマッチの一部を発見できるかもしれませんが、テストはほとんどの場合、決定論的プロセスではなく確率論的プロセスです。
テストは証明の代わりにはなりません。


