---
title: "Category Theory For Programmers Chapter 2"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Scala]
published: false
---

# Chapter 2 Types and Functions  型と関数

型と関数という圏は、プログラミングにおいて重要な役割を果たします。
ここでは、型とは何か、なぜ肩が必要なのかを説明します。

## 2.1 Who Needs Types?  型が必要な人とは？

静的型付けと動的型付け、強い型付けと弱い型付けの利点については、いくつかの論争があるようです。
これらの選択について、思考実験で説明してみましょう。
何百匹ものサルがコンピュータのキーボードで楽しそうにランダムなキーを打ち、プログラムを作り、コンパイルし、実行しているとします。
機械語であれば、猿が作ったどんなバイトの組み合わせでも受け入れて実行することができます。
しかし、上位の言語では、コンパイラが字句や文法の誤りを検出してくれるのはありがたいことです。
多くの猿がバナナを食べずに死んでしまうが、残ったプログラムは役に立つ可能性が高くなります。
型チェックは、無意味なプログラムに対するもう１つの障壁となります。
さらに、動的型付けされた言語では、型の不一致は実行時に発見されますが、強型付けされた静的検査の言語では型の不一致はコンパイル時に発見されるので、多くの間違ったプログラムが実行される前に排除されます。

問題は、猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか、ということです。

タイピングモンキーの思考実験における通常の目標は、シェークスピアの全集を作ることです。
スペルチェッカーと文法チェッカーがループに入っていれば、その確率は飛躍的に高まります。
タイプチェッカーのアナログは更に進んで、ロミオが人間と宣言されたら、葉っぱを生やしたり、強力な重力で講師を閉じ込めたりしないようにする。

## 2.2 Types Are About Composability  型とは合成可能性のこと

圏論とは、矢印を合成することです。
しかし、どんな２つの矢印でも合成することはできません。
ある矢印のターゲットオブジェクトは、次の矢印のソースオブジェクトと同じでなければなりません。
プログラミングでは、ある関数の結果を別の関数に渡します。
ターゲット関数がソース関数の生成したデータを正しく解釈できなければ、プログラムは動作しません。
合成が機能するためには、2 つの端が合わなければなりません。その言語の型システムが強力であればあるほど、この一致を記述し、機械的に検証することができます。

強力な静的型検査に反対する唯一の重大な論点は、意味的に正しいプログラムを排除してしまう可能性があるということです。
実際には、このようなことは極めて稀であり、いずれにしても、どの言語も、本当に必要な場合には、型システムをバイパスするためのなんらかの裏口を用意しています。
しかし、そのような装置は慎重に使うべきです。

型を扱うことはプログラマに大きな負担を強いることになる、というのもよく耳にする議論です。
私自身、 C++ でイテレータの宣言を何度か書いたことがあるので、この意見には共感できましたが、型推論と呼ばれる技術があり、コンパイラが使用されている文脈からほとんどの型を推定することができるようになりました。
C++ では、変数 auto を宣言すると、コンパイラがその型を判断してくれるようになりました。

Haskell では、稀な場合を除いて、型の注釈は純粋にオプションです。
プログラマーは型注釈を使う傾向にあります。
なぜなら、型注釈はコードのセマンティクスについて多くのことを教えてくれるし、、コンパイルエラーを分かりやすくしてくれるからです。
Haskell では、型の設計からプロジェクトを始めるのが一般的です。
その後、型注釈が実装を推進し、コンパイラによって強制されたコメントになります。

強力な静的型付けは、コードをテストしない言い訳としてよく使われます。
Haskell のプログラマが「コンパイルできなら、正しいに違いありません」と言っているのを耳にすることがあります。
もちろん、型付けが正しいプログラムが、正しい出力をするという意味で正しいという保証はありません。
このような軽率な態度の結果、いくつかの研究では、 Haskell はコード品質において、期待されたほど強く優位に立つことができませんでした。
どうやら商業的な環境では、バグを修正するという圧力は、ある品質レベルまでしか適用されず、それはソフトウェア開発の経済性やエンドユーザーの許容範囲と関係があり、プログラミング言語や方法論とはほとんど関係がありません。
もっと良い基準は、どれだけのプロジェクトがスケジュールに遅れたり、機能が大幅に縮小されて納品されたかを測ることです。

ユニットテストが強力な型付けにとって変わることができるという議論については、よく行われるリファクタリングを考えてみましょう: 特定の関数の引数の型を変更すること。
強く型付けされた言語ではその関数の宣言を変更して、全てのビルドブレークを修正するだけで十分です。
弱く型付けされた言語では関数が異なるデータを要求するようになったという事実は、呼び出しサイトには伝わりません。
ユニットテストではミスマッチの一部を発見できるかもしれませんが、テストはほとんどの場合、決定論的プロセスではなく確率論的プロセスです。
テストは証明の代わりにはなりません。

## 2.3 What Are Types?  型とは何か？

型の最も単純な理解は、型は値の集合であるということです。
`Bool` 型 (Scala では、具体的な型は大文字で始まることを覚えていてください)は、 `True` と `False` の２要素の集合です。
Char 型は、 `a` や `å` などの Unicode 文字の集合です。

集合は有限でも無限でも良いです。
`String` 型は、 `Char` 型のリストと同義語で、無限集合の例です。

x を `BigInt` と宣言した場合:

`val x: BigInt`

x は整数の集合の要素であることを言っています。
Scala における BigInt は無限集合であり、任意の精度の算術を行うことができます。
また、 C++ の `int` のように、マシンタイプに対応する有限集合 `Int` もあります。

型と集合の同一視がうまくいかなくなる、いくつかの微妙な点があります。
ポリモーフィック関数には循環的な定義を伴う問題がありますし、全ての集合の集合を持つことはできません。
しかし、お約束したように、私は数学にこだわるつもりはありません。
素晴らしいことに、 Set と呼ばれる集合の圏があり、これを使って作業を進めていきます。
Set では、オブジェクトは集合、モルフィズム(矢印)は関数です。

Set は非常に特別な圏で、実際にオブジェクトの中を覗くことができ、そこから多くの直感を得ることができます。
例えば、空集合には要素がないことが分かっています。
特別な１要素の集合があることを知っています。
関数はある集合の要素を別の集合の要素に写すことができます。
関数は２つの要素を１つに写すことはできますが、１つの要素を２つに写すことはできません。
また、恒等関数は、ある集合の各要素を自分自身に写すということも知っています。
計画では、これらの情報を徐々に忘れていき、代わりにこれらの概念を純粋に圏の言葉で、つまりオブジェクトと矢印で表現します。

理想的な世界では、 Scala の型は集合であり、 Scala の関数は集合間の数学関数であると言えます。
ただ、１つだけ小さな問題があります。
数学関数はコードを実行せず、答えを知るだけです。
Scala の関数は答えを計算しなければなりません。
答えが有限回のステップで得られるのであれば、それは問題ではありません - その数がどんなに大きくても。
しかし、計算の中には再帰を伴うものがあり、それらは決して終了しないかもしれません。
Scala からは終了する関数と終了しない関数を区別することは決定不可能だからです(有名な停止性問題)。
そこで、コンピュータ科学者たちは、全ての型に `ボトム` と呼ばれる(`_|_` または Unicode `⊥`で表される)もう１つの特別な値を加えて拡張するという、素晴らしいアイデアを思いついた(見方によっては大きなハック。見方による)。
それは、
この「値」は、終了しない計算に対応しています。
つまり、次のように宣言された関数は、

`val f: Boolean => Boolean`

`True`, `False`, または `_|_` を返します。
後者は、決して終了しないことを意味します。

面白いことに、型システムの一部としてボトムを受け入れると、全ての実行時エラーをボトムとして扱うことができ、関数がボトムを明示的に返すこともできるようになります。
後者は通常、 `undefined` とう表現を使って以下のように行います。

