---
title: "Category Theory For Programmers"
emoji: "😽"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Scala]
published: false
---

Category Theory For Programmers を読みながら、自分用のメモを作成する。
目的は、圏論を勉強し、自分の中で腹落ちさせること。

# 1. Category: The Essence of Composition  圏論: 合成の本質

圏論は、 オブジェクト とそれらをつなぐ 矢印 で構成されます。

圏論の本質は、 合成 です。

- 物体 A から物体 B に向かう矢印 と、
- 物体 B から物体 C に向かう矢印 があれば、必ず
A から C に向かう矢印 (２つの合成) が存在します。

## 1.1 Arrows as Functions  関数としての矢印

モーフィズム (射) と呼ばれる矢印を、関数として考えてみましょう。
- A 型の引数を取り、 B を返す関数 f と、
- B を受け取って C を返す別の関数 g を持っているとする。
f の結果を g に返すことで、合成することができます。
すると、 A を受け取り、 C を返す新しい関数を定義したことになる。
数学では、このような合成を g ∘ f と表します。
合成の順序は、右から左になっています。
g ∘ f を g after f と読むと分かりやすいでしょう。

C 言語のコードを書いてみて、もっと明確にしてみましょう。
- 型 A の引数を取り、型 B の値を返す関数 f と、
- 型 B の引数を取り、型 C の値を返す関数 g を考えます。 

`B f(A a);`
`C g(B b);`

これらの合成は、

```
C g_after_f(A a)
{
  return g(f(a));
}
```

気分転換に Scala を使ってみましょう。
以下は、 A から B への関数の宣言です。

`val f: A => B`
同様に
`val g: B => C`
これらの合成は、
`g compose f`

Scala ではシンプルに表現できます。

Scala では、コロンは "has the type of ..." という意味です。
関数の型は、2 つの型の間に矢印を挿入して作ります。
2 つの関数の間に compose を挿入すると、2 つの関数を合成できます。

## 1.2 Properties of Composition  合成の性質

どんな圏でも、合成が満たすべき極めて重要な特性が、2 つある。

1. 合成は、連想的です。
3 つのモーフィズム (射) f, g, h があるとし、それらが合成できるとします。
(つまり、それらの物体は端から端まで一致する)
それらを合成するのに括弧は必要ありません。
数学の記法では、以下のように表現されます。

`ℎ ∘ (𝑔 ∘ 𝑓 ) = (ℎ ∘ 𝑔) ∘ 𝑓 = ℎ ∘ 𝑔 ∘ 𝑓`

Scala の擬似コードでは

```
val f: A => B
val g: B => C
val h: C => D

h compose (g compose f) === (h compose g) compose f === h compose g compose f
```

連想法は、関数を扱うときにはかなり明白ですが、他の圏ではそれほど明白ではありません。

2. 全てのオブジェクト A に対して、合成の単位となる矢印があります。
この矢印は、オブジェクトからそれ自身へとループします。
合成の単位であるということは、 A で始まるか A で終わるかのいずれかの矢印とそれぞれ合成すると、同じ矢印が返ってくるということです。
オブジェクト A の単位矢印を id A (Aとの同一性) と呼びます。
数学表では、 f が A から B に行く場合は

```
𝑓 ∘ id𝐴 = 𝑓
id𝐵 ∘ 𝑓 = 𝑓
```

関数を扱う場合、アイデンティティ矢印は、引数を返すだけのアイデンティティ関数として実装されます。
この実装は全ての型で同じであり、つまりこの関数は普遍的なポリモーフィックであることを意味します。

Scala では、 ID 関数は標準ライブラリ (と呼ばれるプレリュード) に含まれています。
以下にその宣言と定義を示します。

```
def identity[A](a: A): A = a
```

ご覧のように、 Scala の多相性(ポリモーフィック)関数は簡単なものです。
宣言の中で、型を型変数に置き換えるだけです。
ここで具体的な型の名前は常に大文字で始まり、型変数の名前は小文字で始まります。
つまり、ここでは a は全ての型を表しています。

関数定義と関数呼び出しは、関数型プログラミングの基本中の基本なので、その構文は必要最低限に抑えられています。
引数リストに括弧がないだけでなく、引数間にもカンマがありません。(後で複数の引数を持つ関数を定義するときにみます)。
関数の本体は常に式で、関数には文がありません。

同一性の条件は、次のように書くこともできます。

```
f compose identity[A] == f
identity[B] _ compose f == f
```

なぜ、何もしない関数である恒等関数をわざわざ使うのでしょうか？
id のような中立的な値は、記号的な変数を扱うときに非常に便利です。
恒等関数は、高階関数の引数や戻り値として、非常に便利なのです。
高階関数は、関数の記号的な操作を可能にします。
つまり、関数の代数です。

要約すると、圏は、オブジェクトと矢印(モーフィズム)から構成されます。
矢印は合成することができ、その合成は連想的です。
全てのオブジェクトには、合成の際に単位となる同一性の矢印があります。

## 1.3 Composition is the Essence of Programming  合成はプログラミングの本質

関数プログラマーは、問題に取り組む際に独特の方法をとります。
まず、禅問答のような質問をします。
例えば、インタラクティブなプログラムを設計するときには、「インタラクションとは何か」と問うでしょう。
また、「コンウェイの人生ゲーム」を実装するときには、「人生の意味」について考えるでしょう。
この精神に基づいて、私は「プログラミングとは何か」を問いかけようと思う。
プログラミングとは、最も基本的なレベルでは、コンピュータに何をすべきかを指示することです。
「メモリアドレス x の内容を取り、レジスタ EAX の内容に加える。」
しかし、アセンブリプログラムであっても、私たちがコンピュータに与える命令は、もっと意味のあることを表現しています。
私たちは、自明ではない問題を解決しているのです。
(自明であれば、コンピュータの助けは必要ありません。)
では、どうやって問題を解決するのか？
大きな問題を小さな問題に分解します。
それでもまだ大きすぎる場合は、さらに分解していきます。
そして最後に、小さな問題を全て解決するコードを書きます。
そして、それらのコードを組み合わせて、より大きな問題を解決するというのが、プログラミングの本質です。
分解しても、それをもとに戻さなければ意味がありません。

このような階層的な分解と再構成のプロセスは、コンピュータが私たちに課したものではありません。
人間の頭脳の限界を表しているのです。
人間の脳は、一度に扱える概念の数が少ないのです。
心理学の分野で最も引用された論文の 1 つである 「The Magical Number Seven, Plus or Minus 2」では、人間は 7 ± 2 の情報の塊しか頭の中に入れておくことができないとしています。
人間の短期記憶についての理解の詳細は変化しているかもしれませんが、限界があることは確かです。
要するに、人間はオブジェクトのスープやコードのスパゲッティを扱うことができない、ということです。
構造化が必要なのは、構造化されたプログラムが見栄えが良いからではなく、そうでなければ脳が効率的に処理できないからです。
よく、コードを「エレガント」とか「美しい」と表現しますが、本当の意味では、人間の限られた頭脳で処理しやすい、ということです。
エレガントなコードは、私たちの心の消化器官が吸収できるように、ちょうど良い大きさと数のチャンクを作ります。

では、プログラムの構成に適した塊とは何か。
体積よりも表面積の方が大きくならないようにしなければなりません。
(この例えが好きなのは、幾何学的な物体の表面積はその大きさの 2 乗で大きくなり、体積はその大きさの 3 乗 で成長するよりも遅いという直感があるからです。)
表面積は、私たちがチャンクを構成するために必要な情報です。
体積は、チャンクを実装するために必要な情報です。
考え方としては、一度チャンクが実装されれば、その実装の詳細は忘れて、他のチャンクとどのように層が作用するかに集中できる、というものです。
オブジェクト指向プログラミングでは、表面積はオブジェクトのクラス宣言、またはその抽象インターフェースです。
また、関数型プログラミングでは、関数の宣言です。

圏論は、極端な話、オブジェクトの中を見ることを積極的に禁止しています。
圏論におけるオブジェクトとは、抽象的で漠然とした存在です。
その物体について知ることができるのは、そのオブジェクトが他のオブジェクトとどのように関係しているか、つまり、矢印を使ってどのように接続しているかだけです。
オブジェクト指向プログラミングでは、理想化されたオブジェクトは、その抽象的なインターフェース(純粋な表面、体積なし)を通して飲み見ることができ、メソッドは矢印の役割を果たします。
オブジェクトを他のものとどのように組み合わせるかを理解するために、オブジェクトの実装にまで踏み込まなければならない時点で、プログラミングパラダイムの利点は失われてしまいます。
